// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/phome/phome.proto

package phome

import (
	fmt "fmt"
	ava "github.com/aiakit/ava"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ChatReq struct {
	Content string `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *ChatReq) Reset()         { *m = ChatReq{} }
func (m *ChatReq) String() string { return proto.CompactTextString(m) }
func (*ChatReq) ProtoMessage()    {}
func (*ChatReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ababc20b4cf82464, []int{0}
}
func (m *ChatReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChatReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChatReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatReq.Merge(m, src)
}
func (m *ChatReq) XXX_Size() int {
	return m.Size()
}
func (m *ChatReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatReq.DiscardUnknown(m)
}

var xxx_messageInfo_ChatReq proto.InternalMessageInfo

func (m *ChatReq) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

type PrepareData struct {
	Objects map[string]*ObjectLogic `protobuf:"bytes,2,rep,name=objects,proto3" json:"objects,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *PrepareData) Reset()         { *m = PrepareData{} }
func (m *PrepareData) String() string { return proto.CompactTextString(m) }
func (*PrepareData) ProtoMessage()    {}
func (*PrepareData) Descriptor() ([]byte, []int) {
	return fileDescriptor_ababc20b4cf82464, []int{1}
}
func (m *PrepareData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepareData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepareData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepareData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepareData.Merge(m, src)
}
func (m *PrepareData) XXX_Size() int {
	return m.Size()
}
func (m *PrepareData) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepareData.DiscardUnknown(m)
}

var xxx_messageInfo_PrepareData proto.InternalMessageInfo

func (m *PrepareData) GetObjects() map[string]*ObjectLogic {
	if m != nil {
		return m.Objects
	}
	return nil
}

type ChatRsp struct {
	Code   int32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg    string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Result string `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *ChatRsp) Reset()         { *m = ChatRsp{} }
func (m *ChatRsp) String() string { return proto.CompactTextString(m) }
func (*ChatRsp) ProtoMessage()    {}
func (*ChatRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ababc20b4cf82464, []int{2}
}
func (m *ChatRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChatRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChatRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatRsp.Merge(m, src)
}
func (m *ChatRsp) XXX_Size() int {
	return m.Size()
}
func (m *ChatRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ChatRsp proto.InternalMessageInfo

func (m *ChatRsp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ChatRsp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ChatRsp) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

type ChatMessage struct {
	Content string `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	Role    string `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *ChatMessage) Reset()         { *m = ChatMessage{} }
func (m *ChatMessage) String() string { return proto.CompactTextString(m) }
func (*ChatMessage) ProtoMessage()    {}
func (*ChatMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_ababc20b4cf82464, []int{3}
}
func (m *ChatMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChatMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChatMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatMessage.Merge(m, src)
}
func (m *ChatMessage) XXX_Size() int {
	return m.Size()
}
func (m *ChatMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ChatMessage proto.InternalMessageInfo

func (m *ChatMessage) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *ChatMessage) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

type ObjectLogic struct {
	Description  string    `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	FunctionName string    `protobuf:"bytes,4,opt,name=FunctionName,proto3" json:"FunctionName,omitempty"`
	Action       []string  `protobuf:"bytes,2,rep,name=action,proto3" json:"action,omitempty"`
	Object       []*Object `protobuf:"bytes,3,rep,name=object,proto3" json:"object,omitempty"`
}

func (m *ObjectLogic) Reset()         { *m = ObjectLogic{} }
func (m *ObjectLogic) String() string { return proto.CompactTextString(m) }
func (*ObjectLogic) ProtoMessage()    {}
func (*ObjectLogic) Descriptor() ([]byte, []int) {
	return fileDescriptor_ababc20b4cf82464, []int{4}
}
func (m *ObjectLogic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectLogic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectLogic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectLogic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectLogic.Merge(m, src)
}
func (m *ObjectLogic) XXX_Size() int {
	return m.Size()
}
func (m *ObjectLogic) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectLogic.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectLogic proto.InternalMessageInfo

func (m *ObjectLogic) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ObjectLogic) GetFunctionName() string {
	if m != nil {
		return m.FunctionName
	}
	return ""
}

func (m *ObjectLogic) GetAction() []string {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *ObjectLogic) GetObject() []*Object {
	if m != nil {
		return m.Object
	}
	return nil
}

type Object struct {
	Name       string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DeviceType string `protobuf:"bytes,2,opt,name=device_type,json=deviceType,proto3" json:"device_type,omitempty"`
	EntityId   string `protobuf:"bytes,3,opt,name=entity_id,json=entityId,proto3" json:"entity_id,omitempty"`
	DeviceId   string `protobuf:"bytes,4,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
}

func (m *Object) Reset()         { *m = Object{} }
func (m *Object) String() string { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()    {}
func (*Object) Descriptor() ([]byte, []int) {
	return fileDescriptor_ababc20b4cf82464, []int{5}
}
func (m *Object) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Object) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Object.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Object) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Object.Merge(m, src)
}
func (m *Object) XXX_Size() int {
	return m.Size()
}
func (m *Object) XXX_DiscardUnknown() {
	xxx_messageInfo_Object.DiscardUnknown(m)
}

var xxx_messageInfo_Object proto.InternalMessageInfo

func (m *Object) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Object) GetDeviceType() string {
	if m != nil {
		return m.DeviceType
	}
	return ""
}

func (m *Object) GetEntityId() string {
	if m != nil {
		return m.EntityId
	}
	return ""
}

func (m *Object) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func init() {
	proto.RegisterType((*ChatReq)(nil), "phome.ChatReq")
	proto.RegisterType((*PrepareData)(nil), "phome.PrepareData")
	proto.RegisterMapType((map[string]*ObjectLogic)(nil), "phome.PrepareData.ObjectsEntry")
	proto.RegisterType((*ChatRsp)(nil), "phome.ChatRsp")
	proto.RegisterType((*ChatMessage)(nil), "phome.chatMessage")
	proto.RegisterType((*ObjectLogic)(nil), "phome.ObjectLogic")
	proto.RegisterType((*Object)(nil), "phome.object")
}

func init() { proto.RegisterFile("proto/phome/phome.proto", fileDescriptor_ababc20b4cf82464) }

var fileDescriptor_ababc20b4cf82464 = []byte{
	// 434 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x52, 0x4d, 0x6f, 0xd3, 0x40,
	0x14, 0xcc, 0x26, 0x4d, 0xd2, 0x3c, 0xb7, 0x08, 0xbd, 0x03, 0x58, 0x45, 0x72, 0x23, 0x23, 0xa4,
	0x70, 0x09, 0x52, 0xb8, 0x40, 0xb9, 0xf1, 0x5d, 0x09, 0x0a, 0xb2, 0xb8, 0x57, 0x5b, 0xfb, 0x29,
	0x59, 0x48, 0x76, 0x17, 0xef, 0xa6, 0xc8, 0xff, 0x02, 0x71, 0xe2, 0x27, 0x71, 0xec, 0x91, 0x23,
	0x4a, 0xfe, 0x08, 0xda, 0x8f, 0x48, 0xce, 0xa1, 0x17, 0xeb, 0xcd, 0xec, 0xec, 0xec, 0x78, 0xf4,
	0xe0, 0xbe, 0xae, 0x95, 0x55, 0x4f, 0xf4, 0x42, 0xad, 0x28, 0x7c, 0xa7, 0x9e, 0xc1, 0xbe, 0x07,
	0xf9, 0x43, 0x18, 0xbe, 0x5a, 0x70, 0x5b, 0xd0, 0x77, 0x4c, 0x61, 0x58, 0x2a, 0x69, 0x49, 0xda,
	0x94, 0x8d, 0xd9, 0x64, 0x54, 0xec, 0x60, 0xfe, 0x9b, 0x41, 0xf2, 0xb9, 0x26, 0xcd, 0x6b, 0x7a,
	0xcd, 0x2d, 0xc7, 0xe7, 0x30, 0x54, 0x57, 0x5f, 0xa9, 0xb4, 0x26, 0xed, 0x8e, 0x7b, 0x93, 0x64,
	0x76, 0x3a, 0x0d, 0xd6, 0x2d, 0xd1, 0xf4, 0x53, 0x50, 0xbc, 0x91, 0xb6, 0x6e, 0x8a, 0x9d, 0xfe,
	0xe4, 0x02, 0x8e, 0xda, 0x07, 0x78, 0x17, 0x7a, 0xdf, 0xa8, 0x89, 0x0f, 0xba, 0x11, 0x27, 0xd0,
	0xbf, 0xe6, 0xcb, 0x35, 0xa5, 0xdd, 0x31, 0x9b, 0x24, 0x33, 0x8c, 0xd6, 0xe1, 0xd6, 0x07, 0x35,
	0x17, 0x65, 0x11, 0x04, 0x67, 0xdd, 0x67, 0x2c, 0x7f, 0x17, 0xf3, 0x1b, 0x8d, 0x08, 0x07, 0xa5,
	0xaa, 0xc8, 0x7b, 0xf5, 0x0b, 0x3f, 0x3b, 0xfb, 0x95, 0x99, 0x7b, 0xab, 0x51, 0xe1, 0x46, 0xbc,
	0x07, 0x83, 0x9a, 0xcc, 0x7a, 0x69, 0xd3, 0x9e, 0x27, 0x23, 0xca, 0x5f, 0x40, 0x52, 0x2e, 0xb8,
	0xfd, 0x48, 0xc6, 0xf0, 0x39, 0xdd, 0x5e, 0x86, 0x7b, 0xa6, 0x56, 0x4b, 0x8a, 0x9e, 0x7e, 0xce,
	0x7f, 0x31, 0x48, 0x5a, 0x01, 0x71, 0x0c, 0x49, 0x45, 0xa6, 0xac, 0x85, 0xb6, 0x42, 0xc9, 0xe8,
	0xd0, 0xa6, 0x30, 0x87, 0xa3, 0xb7, 0x6b, 0x59, 0xba, 0xf9, 0x82, 0xaf, 0x28, 0x3d, 0xf0, 0x92,
	0x3d, 0xce, 0x45, 0xe5, 0x1e, 0xf9, 0x96, 0x47, 0x45, 0x44, 0xf8, 0x08, 0x06, 0xa1, 0xce, 0xb4,
	0xe7, 0xdb, 0x3f, 0x8e, 0x15, 0x05, 0xb2, 0x88, 0x87, 0xf9, 0x8f, 0x9d, 0xcc, 0x45, 0x96, 0xee,
	0x91, 0x90, 0xc3, 0xcf, 0x78, 0xea, 0x22, 0x5e, 0x8b, 0x92, 0x2e, 0x6d, 0xa3, 0x77, 0x7f, 0x03,
	0x81, 0xfa, 0xd2, 0x68, 0xc2, 0x07, 0x30, 0x22, 0x69, 0x85, 0x6d, 0x2e, 0x45, 0x15, 0xbb, 0x3a,
	0x0c, 0xc4, 0x79, 0xe5, 0x0e, 0xe3, 0x6d, 0x51, 0xc5, 0xec, 0x87, 0x81, 0x38, 0xaf, 0x66, 0x67,
	0x70, 0xfc, 0x5e, 0xad, 0x88, 0x1b, 0x23, 0x8c, 0xe5, 0xd2, 0xe2, 0x63, 0x18, 0xc6, 0xcd, 0xc0,
	0x3b, 0x31, 0x6b, 0x5c, 0xba, 0x93, 0x3d, 0x6c, 0xf4, 0xcb, 0xf4, 0xcf, 0x26, 0x63, 0x37, 0x9b,
	0x8c, 0xfd, 0xdb, 0x64, 0xec, 0xe7, 0x36, 0xeb, 0xdc, 0x6c, 0xb3, 0xce, 0xdf, 0x6d, 0xd6, 0xb9,
	0x1a, 0xf8, 0xbd, 0x7d, 0xfa, 0x3f, 0x00, 0x00, 0xff, 0xff, 0xf5, 0x22, 0xc3, 0x44, 0xd2, 0x02,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ ava.Service

// This is a compile-time assertion to ensure that this generated file
// is compatible with the ava package it is being compiled against.
const _ = ava.SupportPackageIsVersion1

type HomeassistantClient interface {
	// 功能预约
	Prepare(c *ava.Context, req *ChatReq, opts ...ava.InvokeOptions) (*ChatRsp, error)
}

type homeassistantClient struct {
	c *ava.Client
}

func NewHomeassistantClient() HomeassistantClient {
	return &homeassistantClient{c: ava.AvaClient()}
}

func (cc *homeassistantClient) Prepare(c *ava.Context, req *ChatReq, opts ...ava.InvokeOptions) (*ChatRsp, error) {
	rsp := &ChatRsp{}
	err := cc.c.InvokeRR(c, "/homeassistant/prepare", req, rsp, opts...)
	return rsp, err
}

// HomeassistantServer is the server API for Homeassistant ava.
type HomeassistantServer interface {
	// 功能预约
	Prepare(c *ava.Context, req *ChatReq, rsp *ChatRsp)
}

func RegisterHomeassistantServer(h HomeassistantServer) {
	var r = &homeassistantHandler{h: h}
	ava.AvaServer().RegisterHandler("/"+ava.AvaServer().Name()+"/homeassistant/prepare", r.Prepare)
}

type homeassistantHandler struct {
	h HomeassistantServer
}

func (r *homeassistantHandler) Prepare(c *ava.Context, req *ava.Packet, interrupt ava.Interceptor) (rsp proto.Message, err error) {
	var in ChatReq
	err = c.Codec().Decode(req.Bytes(), &in)
	if err != nil {
		c.Errorf("server decode packet err=%v |method=%s |data=%s", err, c.Metadata.Method(), req.String())
		return nil, err
	}
	var out = ChatRsp{}
	if interrupt == nil {
		r.h.Prepare(c, &in, &out)
		return &out, err
	}
	f := func(c *ava.Context, req proto.Message) proto.Message {
		r.h.Prepare(c, req.(*ChatReq), &out)
		return &out
	}
	return interrupt(c, &in, f)
}

func (m *ChatReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintPhome(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrepareData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for k := range m.Objects {
			v := m.Objects[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPhome(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPhome(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPhome(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *ChatRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintPhome(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintPhome(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintPhome(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChatMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintPhome(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintPhome(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectLogic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectLogic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectLogic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FunctionName) > 0 {
		i -= len(m.FunctionName)
		copy(dAtA[i:], m.FunctionName)
		i = encodeVarintPhome(dAtA, i, uint64(len(m.FunctionName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Object) > 0 {
		for iNdEx := len(m.Object) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Object[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhome(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Action) > 0 {
		for iNdEx := len(m.Action) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Action[iNdEx])
			copy(dAtA[i:], m.Action[iNdEx])
			i = encodeVarintPhome(dAtA, i, uint64(len(m.Action[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPhome(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Object) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Object) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintPhome(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.EntityId) > 0 {
		i -= len(m.EntityId)
		copy(dAtA[i:], m.EntityId)
		i = encodeVarintPhome(dAtA, i, uint64(len(m.EntityId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeviceType) > 0 {
		i -= len(m.DeviceType)
		copy(dAtA[i:], m.DeviceType)
		i = encodeVarintPhome(dAtA, i, uint64(len(m.DeviceType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPhome(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPhome(dAtA []byte, offset int, v uint64) int {
	offset -= sovPhome(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ChatReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovPhome(uint64(l))
	}
	return n
}

func (m *PrepareData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for k, v := range m.Objects {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPhome(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPhome(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPhome(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ChatRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovPhome(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovPhome(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovPhome(uint64(l))
	}
	return n
}

func (m *ChatMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovPhome(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovPhome(uint64(l))
	}
	return n
}

func (m *ObjectLogic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPhome(uint64(l))
	}
	if len(m.Action) > 0 {
		for _, s := range m.Action {
			l = len(s)
			n += 1 + l + sovPhome(uint64(l))
		}
	}
	if len(m.Object) > 0 {
		for _, e := range m.Object {
			l = e.Size()
			n += 1 + l + sovPhome(uint64(l))
		}
	}
	l = len(m.FunctionName)
	if l > 0 {
		n += 1 + l + sovPhome(uint64(l))
	}
	return n
}

func (m *Object) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPhome(uint64(l))
	}
	l = len(m.DeviceType)
	if l > 0 {
		n += 1 + l + sovPhome(uint64(l))
	}
	l = len(m.EntityId)
	if l > 0 {
		n += 1 + l + sovPhome(uint64(l))
	}
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovPhome(uint64(l))
	}
	return n
}

func sovPhome(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPhome(x uint64) (n int) {
	return sovPhome(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ChatReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhome
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhome
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhome
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhome
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhome(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPhome
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhome
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhome
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhome
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhome
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Objects == nil {
				m.Objects = make(map[string]*ObjectLogic)
			}
			var mapkey string
			var mapvalue *ObjectLogic
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhome
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhome
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhome
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhome
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhome
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPhome
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPhome
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ObjectLogic{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhome(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPhome
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Objects[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhome(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPhome
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhome
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhome
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhome
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhome
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhome
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhome
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhome
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhome
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhome(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPhome
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhome
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: chatMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: chatMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhome
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhome
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhome
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhome
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhome
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhome
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhome(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPhome
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectLogic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhome
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectLogic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectLogic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhome
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhome
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhome
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhome
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhome
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhome
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = append(m.Action, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhome
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhome
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhome
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Object = append(m.Object, &Object{})
			if err := m.Object[len(m.Object)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhome
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhome
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhome
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FunctionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhome(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPhome
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhome
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhome
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhome
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhome
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhome
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhome
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhome
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhome
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhome
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhome
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhome
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhome
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhome
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhome(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPhome
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPhome(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPhome
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPhome
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPhome
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPhome
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPhome
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPhome
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPhome        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPhome          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPhome = fmt.Errorf("proto: unexpected end of group")
)
